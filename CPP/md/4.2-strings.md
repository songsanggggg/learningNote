# 字符串

## 数组风格字符串

![image-20240915114332618](../img/4.2-strings/image-20240915114332618.png)

在字符串中，字符串结束的标志是0,因此第二个字符出现了问题，好的字符串应该是第三个，最后一个\0表示了字符串的结束

![image-20240915114616231](../img/4.2-strings/image-20240915114616231.png)

上部分代码中输出如下

![image-20240915114720176](../img/4.2-strings/image-20240915114720176.png)

我们会发现第二个输出出现了错误

因此数组类型字符串一定要添加0

![image-20240915114856344](../img/4.2-strings/image-20240915114856344.png)

这个函数会输出字符串的长度，字符串的长度和数组长度不相同

在上方代码中输出如下

![image-20240915115052414](../img/4.2-strings/image-20240915115052414.png)

输出结果为2,是因为当遇到\0时候字符串就结束了

## 字符串类型

![image-20240915115220924](../img/4.2-strings/image-20240915115220924.png)

第二个字符串和第一个相同，表示了两个字符串的连接

第三个字符串中数组的元素个数为5,因为还需要一个元素来存储\0

![image-20240915115330503](../img/4.2-strings/image-20240915115330503.png)

上方的char类型没有足够的大小来表示中文或者其他字符，所以我们可以选择下面类型

![image-20240915115430585](../img/4.2-strings/image-20240915115430585.png)

## 字符串的常见操作

### 拷贝

![image-20240915115622276](../img/4.2-strings/image-20240915115622276.png)

原理为内存拷贝，第二个可以避免越界

### 拼接

![image-20240915115718472](../img/4.2-strings/image-20240915115718472.png)

同样也有*strncat()

### 比较

![image-20240915115807617](../img/4.2-strings/image-20240915115807617.png)

### 示例代码

![image-20240915120001074](../img/4.2-strings/image-20240915120001074.png)

输出结果如下

![image-20240915120051886](../img/4.2-strings/image-20240915120051886.png)

![image-20240915120112160](../img/4.2-strings/image-20240915120112160.png)

输出如下

![image-20240915120133644](../img/4.2-strings/image-20240915120133644.png)

## string类

![image-20240915120455433](../img/4.2-strings/image-20240915120455433.png)

string类也没有越界检查