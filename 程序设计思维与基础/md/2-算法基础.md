# 算法基础

## 定义

算法满足下列条件：

	1. 有穷性
	1. 确定性
	1. 能行性
	1. 输入
	1. 输出

## 最大公约数(辗转相除法)

辗转相除法，也称为欧几里得算法，是一种古老且有效的方法，用于计算两个非负整数的最大公约数（GCD）。这种算法的美妙之处在于它的简洁性和对大数字的处理能力，使其在数学和计算机科学领域中广泛应用。

### 算法原理

辗转相除法的基本原理是：两个整数的最大公约数等于其中较小的数和这两个数相除余数的最大公约数。这可以用以下公式表示：

gcd(a, b) = gcd(b, a mod b)

其中 *a mod b* 表示 *a* 除以 *b* 的余数。如果 *b* 为零，则 *a* 就是两数的最大公约数。

### 算法步骤

辗转相除法的步骤可以描述如下：

1. 将两个非负整数 *a* 和 *b* 进行比较，确保 *a* 大于 *b*。
2. 计算 *a* 除以 *b* 的余数 *r*。
3. 如果 *r* 为零，则 *b* 即为最大公约数。
4. 如果 *r* 不为零，则将 *b* 的值赋给 *a*，*r* 的值赋给 *b*，然后重复步骤 2 和 3。

### 代码实现

````c++
int func(int n,int m)
{
    int temp = 0;
    if(n > m)
    {
        temp = m;
        m = n;
        n = temp;
    }
    while(m % n == 0)
    {
        temp = m;
        m = n;
        n = temp % n;
    }
    return n;
}
````

算法经过至多min(a, b)就会停止

## 在指定的位置插入和删除

### 思路

#### 插入

1. 将位置n-1 ,n-2 ......, 1的数据以此后移

2. 讲x存入n位置

#### 删除

1. 将位置i+1, i+2, ......, n-1的数据一次前移一个位置

### 代码输入

````c++
const int MAX_SIZE = 100; // 数组的最大大小

void insertElement(int arr[], int& size, int element, int position) {
    if (position < 0 || position > size || size >= MAX_SIZE) {
        std::cout << "Invalid position or array is full!" << std::endl;
        return;
    }
    // 向后移动元素
    for (int i = size; i > position; --i) {
        arr[i] = arr[i - 1];
    }
    arr[position] = element; // 插入新元素
    size++; // 增加数组大小
    std::cout << "Inserted " << element << " at position " << position << std::endl;
}

void deleteElement(int arr[], int& size, int element) {
    int i;
    for (i = 0; i < size; ++i) {
        if (arr[i] == element) {
            break; // 找到元素
        }
    }
    if (i < size) {
        // 向前移动元素
        for (int j = i; j < size - 1; ++j) {
            arr[j] = arr[j + 1];
        }
        size--; // 减少数组大小
        std::cout << "Deleted " << element << std::endl;
    } else {
        std::cout << "Element " << element << " not found!" << std::endl;
    }
}
````

## 查找算法

### 遍历查找

### 二分查找(有序数组)

## 排序方法

### (交换排序)选择排序

#### 思路

1. 遍历整个数组，将比第一个数大的数字插入到第一个数字之前
2. 从第二个数继续上一步骤，直到所有书子便利完

#### 代码

```c++
void selectionSort(int A[], int n)
{
    for(int i = 0; i < n - 1; i++)
    {
        int j = 1;
        for(int k = i + 1; k < n; k++)
        {
            if(A[k] < A[j])
                j = k;
        }
        swap(A, i ,j);
        print_array(A, n);
	}
}
```

#### 复杂度

时间复杂度为n^2

#### 改进思路

可以不每次都交换，可以记录下标，之后统一交换，减少交换的次数

### 插入排序

### 冒泡排序

#### 思路

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

#### 代码

````c++
void bubbleSort(int numbers[], int size)
{
    int temp = 0;
    for(int i = 0 ; i < size-1; i ++)
    {
    	for(int j = 0 ;j < size-1-i ; j++)
    	{
        	if(numbers[j] > numbers[j+1])  //交换两数位置
        	{
            	temp = numbers[j];
            	numbers[j] = numbers[j+1];
            	numbers[j+1] = temp;
        	}
    	}
    }
}
````



### 归并排序

### 快速排序

