# 算法基础

## 定义

算法满足下列条件：

	1. 有穷性
	1. 确定性
	1. 能行性
	1. 输入
	1. 输出

## 最大公约数(辗转相除法)

辗转相除法，也称为欧几里得算法，是一种古老且有效的方法，用于计算两个非负整数的最大公约数（GCD）。这种算法的美妙之处在于它的简洁性和对大数字的处理能力，使其在数学和计算机科学领域中广泛应用。

### 算法原理

辗转相除法的基本原理是：两个整数的最大公约数等于其中较小的数和这两个数相除余数的最大公约数。这可以用以下公式表示：

gcd(a, b) = gcd(b, a mod b)

其中 *a mod b* 表示 *a* 除以 *b* 的余数。如果 *b* 为零，则 *a* 就是两数的最大公约数。

### 算法步骤

辗转相除法的步骤可以描述如下：

1. 将两个非负整数 *a* 和 *b* 进行比较，确保 *a* 大于 *b*。
2. 计算 *a* 除以 *b* 的余数 *r*。
3. 如果 *r* 为零，则 *b* 即为最大公约数。
4. 如果 *r* 不为零，则将 *b* 的值赋给 *a*，*r* 的值赋给 *b*，然后重复步骤 2 和 3。

### 代码实现

````c++
int func(int n,int m)
{
    int temp = 0;
    if(n > m)
    {
        temp = m;
        m = n;
        n = temp;
    }
    while(m % n == 0)
    {
        temp = m;
        m = n;
        n = temp % n;
    }
    return n;
}
````

算法经过至多min(a, b)就会停止

## 再指定的位置插入和删除

### 思路

#### 插入

1. 将位置n-1 ,n-2 ......, 1的数据以此后移

2. 讲x存入n位置

#### 删除

1. 将位置i+1, i+2, ......, n-1的数据一次前移一个位置

### 代码输入

````c++
const int MAX_SIZE = 100; // 数组的最大大小

void insertElement(int arr[], int& size, int element, int position) {
    if (position < 0 || position > size || size >= MAX_SIZE) {
        std::cout << "Invalid position or array is full!" << std::endl;
        return;
    }
    // 向后移动元素
    for (int i = size; i > position; --i) {
        arr[i] = arr[i - 1];
    }
    arr[position] = element; // 插入新元素
    size++; // 增加数组大小
    std::cout << "Inserted " << element << " at position " << position << std::endl;
}

void deleteElement(int arr[], int& size, int element) {
    int i;
    for (i = 0; i < size; ++i) {
        if (arr[i] == element) {
            break; // 找到元素
        }
    }
    if (i < size) {
        // 向前移动元素
        for (int j = i; j < size - 1; ++j) {
            arr[j] = arr[j + 1];
        }
        size--; // 减少数组大小
        std::cout << "Deleted " << element << std::endl;
    } else {
        std::cout << "Element " << element << " not found!" << std::endl;
    }
}
````

## 查找算法

